[MESSAGE] program {
  grid = Input()

  // Background/separator color: the color that forms full-width uniform rows
  uniform_rows = Find("rows", where="all cells same color")
  bg = ModeColor(uniform_rows)

  // Find horizontal bands (stripes) separated by bg rows
  bands = Find("maximal horizontal bands", where="bounded above and/or below by a full bg row", include_bounds=true)

  // Annotate each band with its edge and fill colors and vertical bounds
  for b in bands {
    left_edge = ColorAt(b, col=0)
    right_edge = ColorAt(b, col=Width(b)-1)
    edge = AssertSame(left_edge, right_edge)
    fill = ModeColor(within=b, exclude=[edge, bg])
    SetAttr(b, {"edge": edge, "fill": fill, "top": TopRow(b), "bottom": BottomRow(b)})
  }

  // Icon zone is the area above the first band
  icon_zone = Subgrid(rows=[0 .. bands[0].top-1], cols=[0 .. Width(grid)-1])

  // Connected components (icons) drawn on the background
  icons = Find("connected components", within=icon_zone, where="color != bg")

  // Projection: copy a component's shape mask to a target band, preserving columns and bottom-aligning to the band
  ProjectToBand = Lambda("project component into matching band") {
    args: component, target_band, paint_color
    src_bbox = BBox(component)
    dest_top = target_band.bottom - Height(src_bbox) + 1
    for cell in Cells(component) {
      dr = dest_top + (Row(cell) - src_bbox.top)
      dc = Col(cell)  // preserve original column
      if dr between target_band.top and target_band.bottom {
        Paint(grid, dr, dc, paint_color)
      }
    }
  }

  // For each icon, send it to the band whose FILL color matches the icon's color; paint with that band's EDGE color
  for icon in icons {
    target = First(bands, where=("fill" == icon.color))
    if target exists {
      Apply(ProjectToBand, component=icon, target_band=target, paint_color=target.edge)
    }
  }

  // Clear the icon zone back to background
  Paint(icon_zone, bg)

  Output(grid)
}

============================================================
Phase: train_0
============================================================
program {
  grid = Input()

  // Background/separator color: the color that forms full-width uniform rows
  uniform_rows = Find("rows", where="all cells same color")
  bg = ModeColor(uniform_rows)

  // Find horizontal bands (stripes) separated by bg rows
  bands = Find("maximal horizontal bands", where="bounded above and/or below by a full bg row", include_bounds=true)

  // Annotate each band with its edge and fill colors and vertical bounds
  for b in bands {
    left_edge = ColorAt(b, col=0)
    right_edge = ColorAt(b, col=Width(b)-1)
    edge = AssertSame(left_edge, right_edge)
    fill = ModeColor(within=b, exclude=[edge, bg])
    SetAttr(b, {"edge": edge, "fill": fill, "top": TopRow(b), "bottom": BottomRow(b)})
  }

  // Icon zone is the area above the first band
  icon_zone = Subgrid(rows=[0 .. bands[0].top-1], cols=[0 .. Width(grid)-1])

  // Connected components (icons) drawn on the background
  icons = Find("connected components", within=icon_zone, where="color != bg")

  // Projection: copy a component's shape mask to a target band, preserving columns and bottom-aligning to the band
  ProjectToBand = Lambda("project component into matching band") {
    args: component, target_band, paint_color
    src_bbox = BBox(component)
    dest_top = target_band.bottom - Height(src_bbox) + 1
    for cell in Cells(component) {
      dr = dest_top + (Row(cell) - src_bbox.top)
      dc = Col(cell)  // preserve original column
      if dr between target_band.top and target_band.bottom {
        Paint(grid, dr, dc, paint_color)
      }
    }
  }

  // For each icon, send it to the band whose FILL color matches the icon's color; paint with that band's EDGE color
  for icon in icons {
    target = First(bands, where=("fill" == icon.color))
    if target exists {
      Apply(ProjectToBand, component=icon, target_band=target, paint_color=target.edge)
    }
  }

  // Clear the icon zone back to background
  Paint(icon_zone, bg)

  Output(grid)
}
[MESSAGE] [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 4, 4, 4, 4, 2, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 4, 2, 2, 4, 2, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 4, 4, 4, 4, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [6, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [6, 4, 6, 6, 4, 4, 4, 4, 4, 6, 6, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [6, 4, 6, 6, 4, 4, 4, 4, 4, 6, 6, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]

============================================================
Phase: train_1_predict
============================================================
[[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 4, 4, 4, 4, 2, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 4, 2, 2, 4, 2, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [4, 4, 4, 4, 4, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [6, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [6, 4, 6, 6, 4, 4, 4, 4, 4, 6, 6, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [6, 4, 6, 6, 4, 4, 4, 4, 4, 6, 6, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]
[MESSAGE] program {
  grid = Input()

  // Background color is the color forming full-width uniform rows (dividers)
  bg = ModeColor(Find("rows", where="all cells same color"))

  // Find horizontal bands separated by bg rows; each band has constant left/right edge and a uniform interior fill
  bands = Find("maximal horizontal bands", where="bounded above/below by full bg rows")
  for b in bands {
    edge_left = ColorAt(b, col=0)
    edge_right = ColorAt(b, col=Width(grid)-1)
    edge = AssertSame(edge_left, edge_right)
    fill = ModeColor(within=b, exclude=[edge, bg])
    Annotate(b, {"edge": edge, "fill": fill, "top": TopRow(b), "bottom": BottomRow(b)})
  }

  // Icon zone is everything above the first band
  icon_zone = Subgrid(rows=[0 .. bands[0].top-1], cols=[0 .. Width(grid)-1])

  // Candidate icons: connected components whose color matches some band's fill (ignore bg and unrelated colors)
  comps_all = Find("connected components", within=icon_zone, where="color != bg")
  valid_fills = { b.fill for b in bands }
  icons = Filter(comps_all, where="component.color in valid_fills")

  // Group icons by their color (the band fill they target)
  groups = GroupBy(icons, key="color")

  // Normalize height within each color group to the minimum height (structure-preserving vertical compression)
  NormalizeHeight = Lambda("compress vertically to target height while preserving top/bottom rows and column mask") {
    args: component, target_height
    return Resample(component, axis="rows", to=target_height, method="nearest", preserve_edges="top,bottom")
  }

  // Project a mask into a band: preserve absolute columns, bottom-align within band, and paint with the band's edge color; do not overwrite edge columns
  ProjectToBand = Lambda("project mask into band") {
    args: mask, band
    paint_color = band.edge
    interior_cols = [1 .. Width(grid)-2]  // exclude edge columns
    base_row = band.bottom - Height(mask) + 1
    translated = Translate(mask, to_row=base_row, to_cols="same columns")
    clipped = Intersect(translated, with=Subgrid(rows=[band.top .. band.bottom], cols=interior_cols))
    Paint(clipped, paint_color)
  }

  // Apply per color group
  for color, group in groups {
    band = First(bands, where=("fill == color"))
    target_h = Min(Height(c) for c in group)
    for comp in group {
      norm = Apply(NormalizeHeight, component=comp, target_height=target_h)
      Apply(ProjectToBand, mask=norm, band=band)
    }
  }

  // Clear the icon zone
  Paint(icon_zone, bg)

  Output(grid)
}

============================================================
Phase: train_1_verify
============================================================
program {
  grid = Input()

  // Background color is the color forming full-width uniform rows (dividers)
  bg = ModeColor(Find("rows", where="all cells same color"))

  // Find horizontal bands separated by bg rows; each band has constant left/right edge and a uniform interior fill
  bands = Find("maximal horizontal bands", where="bounded above/below by full bg rows")
  for b in bands {
    edge_left = ColorAt(b, col=0)
    edge_right = ColorAt(b, col=Width(grid)-1)
    edge = AssertSame(edge_left, edge_right)
    fill = ModeColor(within=b, exclude=[edge, bg])
    Annotate(b, {"edge": edge, "fill": fill, "top": TopRow(b), "bottom": BottomRow(b)})
  }

  // Icon zone is everything above the first band
  icon_zone = Subgrid(rows=[0 .. bands[0].top-1], cols=[0 .. Width(grid)-1])

  // Candidate icons: connected components whose color matches some band's fill (ignore bg and unrelated colors)
  comps_all = Find("connected components", within=icon_zone, where="color != bg")
  valid_fills = { b.fill for b in bands }
  icons = Filter(comps_all, where="component.color in valid_fills")

  // Group icons by their color (the band fill they target)
  groups = GroupBy(icons, key="color")

  // Normalize height within each color group to the minimum height (structure-preserving vertical compression)
  NormalizeHeight = Lambda("compress vertically to target height while preserving top/bottom rows and column mask") {
    args: component, target_height
    return Resample(component, axis="rows", to=target_height, method="nearest", preserve_edges="top,bottom")
  }

  // Project a mask into a band: preserve absolute columns, bottom-align within band, and paint with the band's edge color; do not overwrite edge columns
  ProjectToBand = Lambda("project mask into band") {
    args: mask, band
    paint_color = band.edge
    interior_cols = [1 .. Width(grid)-2]  // exclude edge columns
    base_row = band.bottom - Height(mask) + 1
    translated = Translate(mask, to_row=base_row, to_cols="same columns")
    clipped = Intersect(translated, with=Subgrid(rows=[band.top .. band.bottom], cols=interior_cols))
    Paint(clipped, paint_color)
  }

  // Apply per color group
  for color, group in groups {
    band = First(bands, where=("fill == color"))
    target_h = Min(Height(c) for c in group)
    for comp in group {
      norm = Apply(NormalizeHeight, component=comp, target_height=target_h)
      Apply(ProjectToBand, mask=norm, band=band)
    }
  }

  // Clear the icon zone
  Paint(icon_zone, bg)

  Output(grid)
}
[MESSAGE] [[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4],
 [4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4],
 [4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 8, 8, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6],
 [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6],
 [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6],
 [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6],
 [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6]]

============================================================
Phase: train_2_predict
============================================================
[[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4],
 [4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4],
 [4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 8, 8, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1],
 [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
 [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6],
 [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6],
 [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6],
 [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6],
 [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6]]
[MESSAGE] program {
  grid = Input()

  // 1) Background divider color: the color that appears on full-width uniform rows (most frequent among such rows)
  divider_rows = Find("rows", where="all cells have same color")
  bg = ModeColor(divider_rows)

  // 2) Detect horizontal bands between divider rows
  bands = Find("maximal horizontal bands", where="bounded above and/or below by full-width bg rows")

  // 3) Annotate each band with edge and fill colors
  for b in bands {
    edge_left = ModeColor(Find("cells", within=b, where="col == 0"))
    edge_right = ModeColor(Find("cells", within=b, where=("col == " + (Width(grid)-1))))
    edge = AssertSame(edge_left, edge_right)
    interior = Subgrid(within=b, rows=[TopRow(b) .. BottomRow(b)], cols=[1 .. Width(grid)-2])
    fill = ModeColor(Find("cells", within=interior, where=("color != " + bg + " AND color != " + edge)))
    Annotate(b, {"edge": edge, "fill": fill, "top": TopRow(b), "bottom": BottomRow(b)})
  }

  // 4) Icon zone: area above the first band
  first_band = Min(bands, key="top")
  icon_zone = Subgrid(rows=[0 .. first_band.top-1], cols=[0 .. Width(grid)-1])

  // 5) Candidate icons: components in icon zone whose color matches any band's fill (ignore bg and non-matching colors)
  valid_fills = { b.fill for b in bands }
  components = Find("connected components", within=icon_zone, where=("color != " + bg))
  icons = Filter(components, where=("component.color in valid_fills"))

  // 6) Projection helper: copy icon mask to target band, preserving absolute columns, bottom-aligned within band, paint with the band's edge color; do not paint on edge columns
  ProjectToBand = Lambda("project icon into band") {
    args: icon, band
    paint_color = band.edge
    mask = Mask(icon)  // exact shape of the component, preserving holes
    h = Height(mask)
    dest_top = band.bottom - h + 1
    interior_cols = [1 .. Width(grid)-2]  // exclude edge columns
    target_area = Subgrid(rows=[band.top .. band.bottom], cols=interior_cols)
    placed = Translate(mask, to_row=dest_top, to_cols="same absolute columns")
    clipped = Intersect(placed, with=target_area)
    Paint(clipped, paint_color)
  }

  // 7) For each icon, find the band whose FILL equals the icon's color and project it
  for icon in icons {
    target = First(bands, where=("fill == " + icon.color))
    if target exists {
      Apply(ProjectToBand, icon=icon, band=target)
    }
  }

  // 8) Clear the icon zone to background
  Paint(icon_zone, bg)

  Output(grid)
}

============================================================
Phase: train_2_verify
============================================================
program {
  grid = Input()

  // 1) Background divider color: the color that appears on full-width uniform rows (most frequent among such rows)
  divider_rows = Find("rows", where="all cells have same color")
  bg = ModeColor(divider_rows)

  // 2) Detect horizontal bands between divider rows
  bands = Find("maximal horizontal bands", where="bounded above and/or below by full-width bg rows")

  // 3) Annotate each band with edge and fill colors
  for b in bands {
    edge_left = ModeColor(Find("cells", within=b, where="col == 0"))
    edge_right = ModeColor(Find("cells", within=b, where=("col == " + (Width(grid)-1))))
    edge = AssertSame(edge_left, edge_right)
    interior = Subgrid(within=b, rows=[TopRow(b) .. BottomRow(b)], cols=[1 .. Width(grid)-2])
    fill = ModeColor(Find("cells", within=interior, where=("color != " + bg + " AND color != " + edge)))
    Annotate(b, {"edge": edge, "fill": fill, "top": TopRow(b), "bottom": BottomRow(b)})
  }

  // 4) Icon zone: area above the first band
  first_band = Min(bands, key="top")
  icon_zone = Subgrid(rows=[0 .. first_band.top-1], cols=[0 .. Width(grid)-1])

  // 5) Candidate icons: components in icon zone whose color matches any band's fill (ignore bg and non-matching colors)
  valid_fills = { b.fill for b in bands }
  components = Find("connected components", within=icon_zone, where=("color != " + bg))
  icons = Filter(components, where=("component.color in valid_fills"))

  // 6) Projection helper: copy icon mask to target band, preserving absolute columns, bottom-aligned within band, paint with the band's edge color; do not paint on edge columns
  ProjectToBand = Lambda("project icon into band") {
    args: icon, band
    paint_color = band.edge
    mask = Mask(icon)  // exact shape of the component, preserving holes
    h = Height(mask)
    dest_top = band.bottom - h + 1
    interior_cols = [1 .. Width(grid)-2]  // exclude edge columns
    target_area = Subgrid(rows=[band.top .. band.bottom], cols=interior_cols)
    placed = Translate(mask, to_row=dest_top, to_cols="same absolute columns")
    clipped = Intersect(placed, with=target_area)
    Paint(clipped, paint_color)
  }

  // 7) For each icon, find the band whose FILL equals the icon's color and project it
  for icon in icons {
    target = First(bands, where=("fill == " + icon.color))
    if target exists {
      Apply(ProjectToBand, icon=icon, band=target)
    }
  }

  // 8) Clear the icon zone to background
  Paint(icon_zone, bg)

  Output(grid)
}
[MESSAGE] program {
  grid = Input()

  // 1) Background divider color = color of full-width uniform rows
  divider_rows = Find("rows", where="all cells same color")
  bg = ModeColor(divider_rows)

  // 2) Find horizontal bands (stripes) between divider rows
  raw_spans = Find("contiguous row intervals", where="row is not all bg", separated_by="full-width bg rows")
  bands = Filter(raw_spans, where="ColorAt(span, col=0) == ColorAt(span, col=Width(grid)-1) AND ColorAt(span, col=0) != bg")

  // 3) Annotate band attributes: edge color (left/right) and interior fill color
  for b in bands {
    edge_left = ModeColor(Find("cells", within=b, where="col == 0"))
    edge_right = ModeColor(Find("cells", within=b, where=("col == " + (Width(grid)-1))))
    edge = AssertSame(edge_left, edge_right)
    interior = Subgrid(within=b, rows=[TopRow(b) .. BottomRow(b)], cols=[1 .. Width(grid)-2])
    fill = ModeColor(Find("cells", within=interior, where=("color != " + bg + " AND color != " + edge)))
    Annotate(b, {"edge": edge, "fill": fill, "top": TopRow(b), "bottom": BottomRow(b)})
  }

  // 4) Icon zone: rows above the first band
  first_band = Min(bands, key="top")
  icon_zone = Subgrid(rows=[0 .. first_band.top-1], cols=[0 .. Width(grid)-1])

  // 5) Candidate icons: components in icon zone whose color equals some band's fill
  valid_fills = { b.fill for b in bands }
  candidates = Find("connected components", within=icon_zone, where=("color in " + valid_fills))

  // 6) Normalize height per color group to the minimum height (matches Training 2 behavior)
  groups = GroupBy(candidates, key="color")
  NormalizeHeight = Lambda("compress rows to target height, preserving top/bottom rows and mask shape") {
    args: component, target_height
    return Resample(component, axis="rows", to=target_height, method="nearest", preserve_edges="top,bottom")
  }

  // 7) Projection helper: keep absolute columns, bottom-align within band, paint with band's edge color; do not paint on band edge columns
  ProjectToBand = Lambda("project component into band") {
    args: component, band
    paint_color = band.edge
    mask = Mask(component)   // exact shape, holes preserved
    h = Height(mask)
    dest_top = band.bottom - h + 1
    interior_cols = [1 .. Width(grid)-2]
    band_area = Subgrid(rows=[band.top .. band.bottom], cols=interior_cols)
    placed = Translate(mask, to_row=dest_top, to_cols="same columns")
    clipped = Intersect(placed, with=band_area)
    Paint(clipped, paint_color)
  }

  // 8) Apply normalization + projection for each color group
  for color, comps in groups {
    band = First(bands, where=("fill == " + color))
    target_h = Min(Height(c) for c in comps)
    for c in comps {
      norm = If(Height(c) > target_h, Apply(NormalizeHeight, component=c, target_height=target_h), c)
      Apply(ProjectToBand, component=norm, band=band)
    }
  }

  // 9) Clear the icon zone back to background
  Paint(icon_zone, bg)

  Output(grid)
}

============================================================
Phase: test_refine
============================================================
program {
  grid = Input()

  // 1) Background divider color = color of full-width uniform rows
  divider_rows = Find("rows", where="all cells same color")
  bg = ModeColor(divider_rows)

  // 2) Find horizontal bands (stripes) between divider rows
  raw_spans = Find("contiguous row intervals", where="row is not all bg", separated_by="full-width bg rows")
  bands = Filter(raw_spans, where="ColorAt(span, col=0) == ColorAt(span, col=Width(grid)-1) AND ColorAt(span, col=0) != bg")

  // 3) Annotate band attributes: edge color (left/right) and interior fill color
  for b in bands {
    edge_left = ModeColor(Find("cells", within=b, where="col == 0"))
    edge_right = ModeColor(Find("cells", within=b, where=("col == " + (Width(grid)-1))))
    edge = AssertSame(edge_left, edge_right)
    interior = Subgrid(within=b, rows=[TopRow(b) .. BottomRow(b)], cols=[1 .. Width(grid)-2])
    fill = ModeColor(Find("cells", within=interior, where=("color != " + bg + " AND color != " + edge)))
    Annotate(b, {"edge": edge, "fill": fill, "top": TopRow(b), "bottom": BottomRow(b)})
  }

  // 4) Icon zone: rows above the first band
  first_band = Min(bands, key="top")
  icon_zone = Subgrid(rows=[0 .. first_band.top-1], cols=[0 .. Width(grid)-1])

  // 5) Candidate icons: components in icon zone whose color equals some band's fill
  valid_fills = { b.fill for b in bands }
  candidates = Find("connected components", within=icon_zone, where=("color in " + valid_fills))

  // 6) Normalize height per color group to the minimum height (matches Training 2 behavior)
  groups = GroupBy(candidates, key="color")
  NormalizeHeight = Lambda("compress rows to target height, preserving top/bottom rows and mask shape") {
    args: component, target_height
    return Resample(component, axis="rows", to=target_height, method="nearest", preserve_edges="top,bottom")
  }

  // 7) Projection helper: keep absolute columns, bottom-align within band, paint with band's edge color; do not paint on band edge columns
  ProjectToBand = Lambda("project component into band") {
    args: component, band
    paint_color = band.edge
    mask = Mask(component)   // exact shape, holes preserved
    h = Height(mask)
    dest_top = band.bottom - h + 1
    interior_cols = [1 .. Width(grid)-2]
    band_area = Subgrid(rows=[band.top .. band.bottom], cols=interior_cols)
    placed = Translate(mask, to_row=dest_top, to_cols="same columns")
    clipped = Intersect(placed, with=band_area)
    Paint(clipped, paint_color)
  }

  // 8) Apply normalization + projection for each color group
  for color, comps in groups {
    band = First(bands, where=("fill == " + color))
    target_h = Min(Height(c) for c in comps)
    for c in comps {
      norm = If(Height(c) > target_h, Apply(NormalizeHeight, component=c, target_height=target_h), c)
      Apply(ProjectToBand, component=norm, band=band)
    }
  }

  // 9) Clear the icon zone back to background
  Paint(icon_zone, bg)

  Output(grid)
}
[MESSAGE] [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],
 [3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],
 [3, 1, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],
 [3, 1, 3, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],
 [3, 1, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
 [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
 [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
 [1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4],
 [4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4],
 [4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4],
 [4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 4, 4, 4, 3, 3, 3, 3, 4],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]

============================================================
Phase: test_predict
============================================================
[[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],
 [3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],
 [3, 1, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],
 [3, 1, 3, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],
 [3, 1, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
 [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
 [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
 [1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
 [4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4],
 [4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4],
 [4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4],
 [4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 4, 4, 4, 3, 3, 3, 3, 4],
 [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]
