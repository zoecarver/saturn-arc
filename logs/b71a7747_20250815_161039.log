[MESSAGE] program {
  grid = Input()

  // Identify the repeated solid block color (large filled rectangles)
  rect_comps = Find("connected components", where="filled rectangles, size>=3x3")
  block_color = Mode(Colors(rect_comps), by="component_count")

  // Identify the snake: a single thin, branchless path component
  Lambda("is_thin_path", "component is 4-connected, unit thickness everywhere, all pixels have degree<=2, exactly two endpoints")
  snake = ArgMax(Find("connected components", where="is_thin_path(component)"), by="area")
  snake_color = Color(snake)

  // Crop around the snake with 1-cell padding
  bbox = BoundingBox(snake)
  padded = Expand(bbox, by=1, clamp_to="grid")

  // Render on a uniform canvas of the block_color background
  canvas = NewCanvas(height=padded.height, width=padded.width, fill=block_color)
  shifted_snake = Translate(snake, offset=(-padded.top, -padded.left))
  Paint(canvas, shifted_snake, color=snake_color)

  Output(canvas)
}

============================================================
Phase: train_0
============================================================
program {
  grid = Input()

  // Identify the repeated solid block color (large filled rectangles)
  rect_comps = Find("connected components", where="filled rectangles, size>=3x3")
  block_color = Mode(Colors(rect_comps), by="component_count")

  // Identify the snake: a single thin, branchless path component
  Lambda("is_thin_path", "component is 4-connected, unit thickness everywhere, all pixels have degree<=2, exactly two endpoints")
  snake = ArgMax(Find("connected components", where="is_thin_path(component)"), by="area")
  snake_color = Color(snake)

  // Crop around the snake with 1-cell padding
  bbox = BoundingBox(snake)
  padded = Expand(bbox, by=1, clamp_to="grid")

  // Render on a uniform canvas of the block_color background
  canvas = NewCanvas(height=padded.height, width=padded.width, fill=block_color)
  shifted_snake = Translate(snake, offset=(-padded.top, -padded.left))
  Paint(canvas, shifted_snake, color=snake_color)

  Output(canvas)
}
[MESSAGE] [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 8, 8, 3, 3, 3, 8, 8, 8, 3, 3, 3, 8, 8, 8, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 8, 3, 3, 3, 8, 8, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]]

============================================================
Phase: train_1_predict
============================================================
[[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 8, 8, 3, 3, 3, 8, 8, 8, 3, 3, 3, 8, 8, 8, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 8, 8, 3, 3, 3, 8, 8, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3, 3],
 [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]]
[MESSAGE] program {
  grid = Input()

  // 1) Identify the path color as the color whose pixels form only unit-thick, branchless strokes
  comps = Find("connected components", where="unit_thickness AND max_degree<=2")
  thin_by_color = Group(comps, key="color")
  path_color = ArgMax(thin_by_color, by="sum(area)")
  path = Union(Filter(comps, where="color==path_color"))

  // 2) Choose background as the most common 4-neighbor color touching the path
  host_color = Mode(Colors(Neighbors4(path), exclude=path_color))

  // 3) Crop to the path with 1-cell padding
  box = Expand(BoundingBox(path), by=1, clamp_to="grid")
  path_crop = Crop(path, to=box)

  // 4) Fill between extremes on rows and columns to connect disjoint path fragments into a single orthogonal stroke
  FillRowExtremes = Lambda("row_span", "for each row: if >=2 path pixels, paint the continuous run from leftmost to rightmost as path")
  FillColExtremes = Lambda("col_span", "for each column: if >=2 path pixels, paint the continuous run from topmost to bottommost as path")

  row_filled = Apply(FillRowExtremes, to=path_crop)
  full_filled = Apply(FillColExtremes, to=row_filled)

  // 5) Render on a uniform canvas of the host color
  canvas = NewCanvas(height=box.height, width=box.width, fill=host_color)
  Paint(canvas, full_filled, color=path_color)

  Output(canvas)
}

============================================================
Phase: train_1_verify
============================================================
program {
  grid = Input()

  // 1) Identify the path color as the color whose pixels form only unit-thick, branchless strokes
  comps = Find("connected components", where="unit_thickness AND max_degree<=2")
  thin_by_color = Group(comps, key="color")
  path_color = ArgMax(thin_by_color, by="sum(area)")
  path = Union(Filter(comps, where="color==path_color"))

  // 2) Choose background as the most common 4-neighbor color touching the path
  host_color = Mode(Colors(Neighbors4(path), exclude=path_color))

  // 3) Crop to the path with 1-cell padding
  box = Expand(BoundingBox(path), by=1, clamp_to="grid")
  path_crop = Crop(path, to=box)

  // 4) Fill between extremes on rows and columns to connect disjoint path fragments into a single orthogonal stroke
  FillRowExtremes = Lambda("row_span", "for each row: if >=2 path pixels, paint the continuous run from leftmost to rightmost as path")
  FillColExtremes = Lambda("col_span", "for each column: if >=2 path pixels, paint the continuous run from topmost to bottommost as path")

  row_filled = Apply(FillRowExtremes, to=path_crop)
  full_filled = Apply(FillColExtremes, to=row_filled)

  // 5) Render on a uniform canvas of the host color
  canvas = NewCanvas(height=box.height, width=box.width, fill=host_color)
  Paint(canvas, full_filled, color=path_color)

  Output(canvas)
}
[MESSAGE] program {
  grid = Input()

  // 1) Detect the thin stroke color (the “snake”)
  thin = Find("connected components", where="color!=0 AND unit_thickness AND no 2x2 blocks")
  by_color = Group(thin, key="color")
  gridlike_colors = Colors(Filter(thin, where="exists pixel with degree>=3"))  // e.g., lattice lines with junctions
  path_color = ArgMax(by_color, by="sum(area)", exclude=gridlike_colors)
  path = Union(Filter(thin, where="color==path_color"))

  // 2) Choose the host/background as the dominant color surrounding the path,
  //    preferring solid-region colors over line colors
  weighted_adj = CountColors(Neighbors4(path), weight="dominance of that color in 3x3 around each path pixel")
  host_color = ArgMax(weighted_adj, exclude=[path_color] + gridlike_colors)

  // 3) Crop tightly around the path with a 1-cell margin
  box = Expand(BoundingBox(path), by=1, clamp_to="grid")
  path_crop = Translate(Intersect(path, box), offset=(-box.top, -box.left))

  // 4) Complete the stroke by spanning between extremes on rows and columns, iterate to stability
  FillRowExtremes = Lambda("row_span", "for each row: if >=2 path pixels, paint the continuous run from leftmost to rightmost as path_color")
  FillColExtremes = Lambda("col_span", "for each column: if >=2 path pixels, paint the continuous run from topmost to bottommost as path_color")
  completed = Repeat([
      Apply(FillRowExtremes, to=path_crop),
      Apply(FillColExtremes, to="result")
    ], until="no change", max=3)

  // 5) Render on a uniform canvas of the chosen host/background color
  canvas = NewCanvas(height=box.height, width=box.width, fill=host_color)
  Paint(canvas, completed, color=path_color)

  Output(canvas)
}

============================================================
Phase: test_refine
============================================================
program {
  grid = Input()

  // 1) Detect the thin stroke color (the “snake”)
  thin = Find("connected components", where="color!=0 AND unit_thickness AND no 2x2 blocks")
  by_color = Group(thin, key="color")
  gridlike_colors = Colors(Filter(thin, where="exists pixel with degree>=3"))  // e.g., lattice lines with junctions
  path_color = ArgMax(by_color, by="sum(area)", exclude=gridlike_colors)
  path = Union(Filter(thin, where="color==path_color"))

  // 2) Choose the host/background as the dominant color surrounding the path,
  //    preferring solid-region colors over line colors
  weighted_adj = CountColors(Neighbors4(path), weight="dominance of that color in 3x3 around each path pixel")
  host_color = ArgMax(weighted_adj, exclude=[path_color] + gridlike_colors)

  // 3) Crop tightly around the path with a 1-cell margin
  box = Expand(BoundingBox(path), by=1, clamp_to="grid")
  path_crop = Translate(Intersect(path, box), offset=(-box.top, -box.left))

  // 4) Complete the stroke by spanning between extremes on rows and columns, iterate to stability
  FillRowExtremes = Lambda("row_span", "for each row: if >=2 path pixels, paint the continuous run from leftmost to rightmost as path_color")
  FillColExtremes = Lambda("col_span", "for each column: if >=2 path pixels, paint the continuous run from topmost to bottommost as path_color")
  completed = Repeat([
      Apply(FillRowExtremes, to=path_crop),
      Apply(FillColExtremes, to="result")
    ], until="no change", max=3)

  // 5) Render on a uniform canvas of the chosen host/background color
  canvas = NewCanvas(height=box.height, width=box.width, fill=host_color)
  Paint(canvas, completed, color=path_color)

  Output(canvas)
}
[MESSAGE] [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]

============================================================
Phase: test_predict
============================================================
[[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]
