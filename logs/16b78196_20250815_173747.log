[MESSAGE] program {
  grid = Input()

  // 1) Identify the platform (brown) and its usable attachment points (holes/openings)
  platform = Find("largest connected component", where="color == 8")
  top_edge = Boundary(platform, side="top")
  bot_edge = Boundary(platform, side="bottom")

  holes_up   = Find("contiguous zero runs", where="adjacent to top_edge")
  holes_down = Find("contiguous zero runs", where="adjacent to bot_edge")

  anchor_top = Center(Leftmost(holes_up))
  anchor_bot = Center(Nearest(holes_down, to=Midpoint(platform)))

  // 2) Collect all non-background, non-platform pieces and split by side
  pieces = Find("connected components", where="color != 0 and color != 8")
  above  = Filter(pieces, where="Above(component, platform)")
  below  = Filter(pieces, where="Below(component, platform)")

  // 3) Partition pieces into two piles (left/top pile and right/bottom pile)
  //    Heuristic consistent with the example:
  //    - Send the rightmost ABOVE piece to the top pile; the rest of ABOVE go to bottom pile
  //    - Send all BELOW pieces except the rightmost to the top pile; the rightmost BELOW to the bottom pile
  top_above_pick    = Rightmost(above)
  bottom_above_rest = Subtract(above, top_above_pick)

  bottom_below_pick = Rightmost(below)
  top_below_rest    = Subtract(below, bottom_below_pick)

  pile_top    = Union(top_above_pick, top_below_rest)
  pile_bottom = Union(bottom_above_rest, bottom_below_pick)

  // 4) Paint each pile by stacking onto the platform at its anchor.
  //    Order within a pile: farthest-from-platform first (so nearer pieces overwrite).
  PaintPile = Lambda("stack_pile") {
    ordered = Sort(pile, key=Distance(Centroid(component), platform), order="descending")
    for comp in ordered {
      target = Touch(platform, side=side, at=anchor, align="center")
      MovePaint(comp, to=target, mode="overwrite")
    }
  }

  Apply(PaintPile, args=[pile_top, anchor_top, "above"])
  Apply(PaintPile, args=[pile_bottom, anchor_bot, "below"])

  Output(grid)
}

============================================================
Phase: train_0
============================================================
program {
  grid = Input()

  // 1) Identify the platform (brown) and its usable attachment points (holes/openings)
  platform = Find("largest connected component", where="color == 8")
  top_edge = Boundary(platform, side="top")
  bot_edge = Boundary(platform, side="bottom")

  holes_up   = Find("contiguous zero runs", where="adjacent to top_edge")
  holes_down = Find("contiguous zero runs", where="adjacent to bot_edge")

  anchor_top = Center(Leftmost(holes_up))
  anchor_bot = Center(Nearest(holes_down, to=Midpoint(platform)))

  // 2) Collect all non-background, non-platform pieces and split by side
  pieces = Find("connected components", where="color != 0 and color != 8")
  above  = Filter(pieces, where="Above(component, platform)")
  below  = Filter(pieces, where="Below(component, platform)")

  // 3) Partition pieces into two piles (left/top pile and right/bottom pile)
  //    Heuristic consistent with the example:
  //    - Send the rightmost ABOVE piece to the top pile; the rest of ABOVE go to bottom pile
  //    - Send all BELOW pieces except the rightmost to the top pile; the rightmost BELOW to the bottom pile
  top_above_pick    = Rightmost(above)
  bottom_above_rest = Subtract(above, top_above_pick)

  bottom_below_pick = Rightmost(below)
  top_below_rest    = Subtract(below, bottom_below_pick)

  pile_top    = Union(top_above_pick, top_below_rest)
  pile_bottom = Union(bottom_above_rest, bottom_below_pick)

  // 4) Paint each pile by stacking onto the platform at its anchor.
  //    Order within a pile: farthest-from-platform first (so nearer pieces overwrite).
  PaintPile = Lambda("stack_pile") {
    ordered = Sort(pile, key=Distance(Centroid(component), platform), order="descending")
    for comp in ordered {
      target = Touch(platform, side=side, at=anchor, align="center")
      MovePaint(comp, to=target, mode="overwrite")
    }
  }

  Apply(PaintPile, args=[pile_top, anchor_top, "above"])
  Apply(PaintPile, args=[pile_bottom, anchor_bot, "below"])

  Output(grid)
}
[MESSAGE] [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2],
 [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 4, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

============================================================
Phase: train_1_predict
============================================================
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2],
 [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 4, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
[MESSAGE] program {
  grid = Input()

  // 1) Identify the horizontal platform
  platform = Find("largest connected component", where="nonzero and horizontally extensive")
  plat_color = Color(platform)

  // 2) Detect bottom notches (one-cell wide mouths under the platform)
  BottomMouth = Lambda("bottom_notch", "a zero cell whose up neighbor is platform and whose left-up and right-up neighbors are also platform")
  notches = Find(BottomMouth, within=Neighborhood(platform, radius=1))

  notch_axes = Map(notches, fn=Col)   // each notch’s column index

  // 3) Collect non-platform pieces and split by side
  pieces = Find("connected components", where=f"color != 0 and color != {plat_color}")
  above  = Filter(pieces, where="Above(component, platform)")
  below  = Filter(pieces, where="Below(component, platform)")

  // 4) Claim notches using pieces above the platform:
  //    a piece claims a notch if its horizontal span covers the notch axis (tie-breaker: nearest axis to its centroid)
  Span = Lambda("span", returns="min_col..max_col")
  ClaimAxis = Lambda("claim_axis") {
    span = Span(component)
    candidates = Filter(notch_axes, where="axis in span")
    if Empty(candidates) { return None }
    return Nearest(candidates, to=Col(Centroid(component)))
  }

  claims = { comp: ClaimAxis(comp) for comp in above }
  anchors = Unique(Filter(Map(claims, fn=Value), where="not None"))

  // 5) Erase original piece locations
  Erase(pieces)

  // 6) For each claimed anchor, build a stack:
  BuildStack = Lambda("build_stack_at_axis") {
    axis = anchor

    // top element: the closest above-claimant (if multiple) to the platform
    top_candidates = Filter(above, where="claims[this] == axis")
    if Empty(top_candidates) { return }  // no above piece, skip this anchor
    top_piece = Nearest(top_candidates, to=platform, metric="vertical")

    // queue from below: pieces whose horizontal span covers the same axis, sorted by upward distance to platform
    bottom_queue = Sort(
      Filter(below, where="axis in Span(component)"),
      key=Distance(component, platform), order="ascending"
    )

    stack = [top_piece] + bottom_queue

    // 7) Place the stack: align each piece by centroid to the axis; drop each to rest on the previous content
    drop_line = Row(BottomBoundary(platform, at_col=axis)) + 1

    PlacePiece = Lambda("place") {
      target_x = axis
      Move(piece, to=("any row, col such that Col(Centroid(piece)) == target_x"), align="centroid horizontally")
      Drop(piece, direction="down", until="touching platform or any already placed piece")
    }

    for piece in stack { Apply(PlacePiece, to=piece) }
  }

  // Apply stacks at all claimed anchors, left-to-right for determinism
  for anchor in Sort(anchors, order="ascending") {
    Apply(BuildStack, args=[anchor])
  }

  Output(grid)
}

============================================================
Phase: train_1_verify
============================================================
program {
  grid = Input()

  // 1) Identify the horizontal platform
  platform = Find("largest connected component", where="nonzero and horizontally extensive")
  plat_color = Color(platform)

  // 2) Detect bottom notches (one-cell wide mouths under the platform)
  BottomMouth = Lambda("bottom_notch", "a zero cell whose up neighbor is platform and whose left-up and right-up neighbors are also platform")
  notches = Find(BottomMouth, within=Neighborhood(platform, radius=1))

  notch_axes = Map(notches, fn=Col)   // each notch’s column index

  // 3) Collect non-platform pieces and split by side
  pieces = Find("connected components", where=f"color != 0 and color != {plat_color}")
  above  = Filter(pieces, where="Above(component, platform)")
  below  = Filter(pieces, where="Below(component, platform)")

  // 4) Claim notches using pieces above the platform:
  //    a piece claims a notch if its horizontal span covers the notch axis (tie-breaker: nearest axis to its centroid)
  Span = Lambda("span", returns="min_col..max_col")
  ClaimAxis = Lambda("claim_axis") {
    span = Span(component)
    candidates = Filter(notch_axes, where="axis in span")
    if Empty(candidates) { return None }
    return Nearest(candidates, to=Col(Centroid(component)))
  }

  claims = { comp: ClaimAxis(comp) for comp in above }
  anchors = Unique(Filter(Map(claims, fn=Value), where="not None"))

  // 5) Erase original piece locations
  Erase(pieces)

  // 6) For each claimed anchor, build a stack:
  BuildStack = Lambda("build_stack_at_axis") {
    axis = anchor

    // top element: the closest above-claimant (if multiple) to the platform
    top_candidates = Filter(above, where="claims[this] == axis")
    if Empty(top_candidates) { return }  // no above piece, skip this anchor
    top_piece = Nearest(top_candidates, to=platform, metric="vertical")

    // queue from below: pieces whose horizontal span covers the same axis, sorted by upward distance to platform
    bottom_queue = Sort(
      Filter(below, where="axis in Span(component)"),
      key=Distance(component, platform), order="ascending"
    )

    stack = [top_piece] + bottom_queue

    // 7) Place the stack: align each piece by centroid to the axis; drop each to rest on the previous content
    drop_line = Row(BottomBoundary(platform, at_col=axis)) + 1

    PlacePiece = Lambda("place") {
      target_x = axis
      Move(piece, to=("any row, col such that Col(Centroid(piece)) == target_x"), align="centroid horizontally")
      Drop(piece, direction="down", until="touching platform or any already placed piece")
    }

    for piece in stack { Apply(PlacePiece, to=piece) }
  }

  // Apply stacks at all claimed anchors, left-to-right for determinism
  for anchor in Sort(anchors, order="ascending") {
    Apply(BuildStack, args=[anchor])
  }

  Output(grid)
}
[MESSAGE] program {
  grid = Input()

  // Identify the dominant "platform" (largest single-color component)
  platform = MaxArea(Find("connected components", where="color != 0"))
  plat_color = Color(platform)

  // Determine platform orientation
  orient = If(Width(platform) >= Height(platform), "horizontal", "vertical")

  // Generic notch detectors (one-cell wide mouths along a given side)
  MouthTop    = Lambda("top_notch",    "zero cell y such that Down(y) in platform and DownLeft(y) in platform and DownRight(y) in platform")
  MouthBottom = Lambda("bottom_notch", "zero cell y such that Up(y)   in platform and UpLeft(y)   in platform and UpRight(y)   in platform")
  MouthLeft   = Lambda("left_notch",   "zero cell y such that Right(y) in platform and UpRight(y) in platform and DownRight(y) in platform")
  MouthRight  = Lambda("right_notch",  "zero cell y such that Left(y)  in platform and UpLeft(y)  in platform and DownLeft(y)  in platform")

  // Collect all non-platform pieces
  pieces = Find("connected components", where=f"color != 0 and color != {plat_color}")

  // Side partitions and anchors
  if orient == "horizontal" {
    top_pieces = Filter(pieces, where="Above(component, platform)")
    bot_pieces = Filter(pieces, where="Below(component, platform)")

    top_notches = Find(MouthTop)
    bot_notches = Find(MouthBottom)

    // Anchor is the notch whose axis (column) is closest to the centroid of the side’s pieces; fallback to platform center
    top_axis = If(Empty(top_pieces), Col(Centroid(platform)), Nearest(Map(top_notches, Col), to=Col(Centroid(Union(top_pieces)))))
    bot_axis = If(Empty(bot_pieces), Col(Centroid(platform)), Nearest(Map(bot_notches, Col), to=Col(Centroid(Union(bot_pieces)))))

    // Decide stacks: if both sides have pieces, build both; else build a single stack on whichever side has pieces (use all pieces)
    if Empty(top_pieces) or Empty(bot_pieces) {
      pile = Union(top_pieces, bot_pieces)
      side = If(Empty(bot_pieces), "above", "below")
      axis = If(Empty(bot_pieces), top_axis, bot_axis)
      Apply(Lambda("BuildVerticalStack"), args=[pile, side, axis, platform])
    } else {
      Apply(Lambda("BuildVerticalStack"), args=[top_pieces, "above", top_axis, platform])
      Apply(Lambda("BuildVerticalStack"), args=[bot_pieces, "below", bot_axis, platform])
    }
  } else { // vertical platform (TEST INPUT CASE)
    left_pieces  = Filter(pieces, where="LeftOf(component, platform)")
    right_pieces = Filter(pieces, where="RightOf(component, platform)")

    left_notches  = Find(MouthLeft)
    right_notches = Find(MouthRight)

    // Anchor is the notch whose axis (row) is closest to the centroid of the side’s pieces; fallback to platform center row
    left_axis  = If(Empty(left_pieces),  Row(Centroid(platform)), Nearest(Map(left_notches, Row),  to=Row(Centroid(Union(left_pieces)))))
    right_axis = If(Empty(right_pieces), Row(Centroid(platform)), Nearest(Map(right_notches, Row), to=Row(Centroid(Union(right_pieces)))))

    // If only one side has pieces, build a single horizontal stack at that side using ALL pieces.
    // If both sides have pieces, build two stacks independently at their nearest-row notches.
    if Empty(left_pieces) or Empty(right_pieces) {
      pile = Union(left_pieces, right_pieces)
      side = If(Empty(right_pieces), "left", "right")
      axis = If(Empty(right_pieces), left_axis, right_axis)
      Apply(Lambda("BuildHorizontalStack"), args=[pile, side, axis, platform])
    } else {
      Apply(Lambda("BuildHorizontalStack"), args=[left_pieces,  "left",  left_axis,  platform])
      Apply(Lambda("BuildHorizontalStack"), args=[right_pieces, "right", right_axis, platform])
    }
  }

  // Placement lambdas

  BuildVerticalStack = Lambda("BuildVerticalStack(pile, side, axis_col, platform)") {
    // Order farthest-first so nearer pieces overwrite/finalize on top
    ordered = Sort(pile, key=Distance(Centroid(component), platform), order="descending")
    Erase(pile)
    base = platform
    for comp in ordered {
      Align(comp, to_col=axis_col, method="centroid")
      Attach(comp, to=base, side=If(side=="above","top","bottom"), at_col=axis_col, align="center")
      base = comp
    }
  }

  BuildHorizontalStack = Lambda("BuildHorizontalStack(pile, side, axis_row, platform)") {
    // Order farthest-first so nearer pieces overwrite/finalize on the inner side
    ordered = Sort(pile, key=Distance(Centroid(component), platform), order="descending")
    Erase(pile)
    base = platform
    for comp in ordered {
      Align(comp, to_row=axis_row, method="centroid")
      Attach(comp, to=base, side=If(side=="left","left","right"), at_row=axis_row, align="center")
      base = comp
    }
  }

  Output(grid)
}

============================================================
Phase: test_refine
============================================================
program {
  grid = Input()

  // Identify the dominant "platform" (largest single-color component)
  platform = MaxArea(Find("connected components", where="color != 0"))
  plat_color = Color(platform)

  // Determine platform orientation
  orient = If(Width(platform) >= Height(platform), "horizontal", "vertical")

  // Generic notch detectors (one-cell wide mouths along a given side)
  MouthTop    = Lambda("top_notch",    "zero cell y such that Down(y) in platform and DownLeft(y) in platform and DownRight(y) in platform")
  MouthBottom = Lambda("bottom_notch", "zero cell y such that Up(y)   in platform and UpLeft(y)   in platform and UpRight(y)   in platform")
  MouthLeft   = Lambda("left_notch",   "zero cell y such that Right(y) in platform and UpRight(y) in platform and DownRight(y) in platform")
  MouthRight  = Lambda("right_notch",  "zero cell y such that Left(y)  in platform and UpLeft(y)  in platform and DownLeft(y)  in platform")

  // Collect all non-platform pieces
  pieces = Find("connected components", where=f"color != 0 and color != {plat_color}")

  // Side partitions and anchors
  if orient == "horizontal" {
    top_pieces = Filter(pieces, where="Above(component, platform)")
    bot_pieces = Filter(pieces, where="Below(component, platform)")

    top_notches = Find(MouthTop)
    bot_notches = Find(MouthBottom)

    // Anchor is the notch whose axis (column) is closest to the centroid of the side’s pieces; fallback to platform center
    top_axis = If(Empty(top_pieces), Col(Centroid(platform)), Nearest(Map(top_notches, Col), to=Col(Centroid(Union(top_pieces)))))
    bot_axis = If(Empty(bot_pieces), Col(Centroid(platform)), Nearest(Map(bot_notches, Col), to=Col(Centroid(Union(bot_pieces)))))

    // Decide stacks: if both sides have pieces, build both; else build a single stack on whichever side has pieces (use all pieces)
    if Empty(top_pieces) or Empty(bot_pieces) {
      pile = Union(top_pieces, bot_pieces)
      side = If(Empty(bot_pieces), "above", "below")
      axis = If(Empty(bot_pieces), top_axis, bot_axis)
      Apply(Lambda("BuildVerticalStack"), args=[pile, side, axis, platform])
    } else {
      Apply(Lambda("BuildVerticalStack"), args=[top_pieces, "above", top_axis, platform])
      Apply(Lambda("BuildVerticalStack"), args=[bot_pieces, "below", bot_axis, platform])
    }
  } else { // vertical platform (TEST INPUT CASE)
    left_pieces  = Filter(pieces, where="LeftOf(component, platform)")
    right_pieces = Filter(pieces, where="RightOf(component, platform)")

    left_notches  = Find(MouthLeft)
    right_notches = Find(MouthRight)

    // Anchor is the notch whose axis (row) is closest to the centroid of the side’s pieces; fallback to platform center row
    left_axis  = If(Empty(left_pieces),  Row(Centroid(platform)), Nearest(Map(left_notches, Row),  to=Row(Centroid(Union(left_pieces)))))
    right_axis = If(Empty(right_pieces), Row(Centroid(platform)), Nearest(Map(right_notches, Row), to=Row(Centroid(Union(right_pieces)))))

    // If only one side has pieces, build a single horizontal stack at that side using ALL pieces.
    // If both sides have pieces, build two stacks independently at their nearest-row notches.
    if Empty(left_pieces) or Empty(right_pieces) {
      pile = Union(left_pieces, right_pieces)
      side = If(Empty(right_pieces), "left", "right")
      axis = If(Empty(right_pieces), left_axis, right_axis)
      Apply(Lambda("BuildHorizontalStack"), args=[pile, side, axis, platform])
    } else {
      Apply(Lambda("BuildHorizontalStack"), args=[left_pieces,  "left",  left_axis,  platform])
      Apply(Lambda("BuildHorizontalStack"), args=[right_pieces, "right", right_axis, platform])
    }
  }

  // Placement lambdas

  BuildVerticalStack = Lambda("BuildVerticalStack(pile, side, axis_col, platform)") {
    // Order farthest-first so nearer pieces overwrite/finalize on top
    ordered = Sort(pile, key=Distance(Centroid(component), platform), order="descending")
    Erase(pile)
    base = platform
    for comp in ordered {
      Align(comp, to_col=axis_col, method="centroid")
      Attach(comp, to=base, side=If(side=="above","top","bottom"), at_col=axis_col, align="center")
      base = comp
    }
  }

  BuildHorizontalStack = Lambda("BuildHorizontalStack(pile, side, axis_row, platform)") {
    // Order farthest-first so nearer pieces overwrite/finalize on the inner side
    ordered = Sort(pile, key=Distance(Centroid(component), platform), order="descending")
    Erase(pile)
    base = platform
    for comp in ordered {
      Align(comp, to_row=axis_row, method="centroid")
      Attach(comp, to=base, side=If(side=="left","left","right"), at_row=axis_row, align="center")
      base = comp
    }
  }

  Output(grid)
}
[MESSAGE] [[0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 4, 4, 4, 4, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 4, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0],
 [0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 4, 4, 4, 4, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [6, 6, 6, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [6, 6, 6, 6, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

============================================================
Phase: test_predict
============================================================
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 4, 4, 4, 4, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 4, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0],
 [0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 4, 4, 4, 4, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [6, 6, 6, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [6, 6, 6, 6, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
