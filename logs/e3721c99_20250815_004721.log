[MESSAGE] Program "PaletteHolesRecolor"

Definitions:
- Conn = 4
- Holes(shape) = Count(Find("black regions", within=shape, where="fully enclosed by shape", conn=Conn))
- RegionAbove(row) = rows [0..row-1]
- RegionBelow(row) = rows [row+1..end]

Steps:
1) divider = Find("full-width horizontal stripe", where="all cells same nonzero color", extent="entire row")
2) top = RegionAbove(divider.row)
   bottom = RegionBelow(divider.row)

3) palette_swatches = Find("connected components", within=top, where="color != 0", conn=Conn)
   color_map = {}
   for swatch in palette_swatches:
       k = Holes(swatch)
       color_map[k] = ColorOf(swatch)

4) targets = Find("connected components", within=bottom, where="color != 0", conn=Conn)
   for shape in targets:
       k = Holes(shape)
       new_color = color_map[k]
       Paint(shape, new_color, preserve="black (0) holes")

5) Return canvas

============================================================
Phase: train_0
============================================================
Program "PaletteHolesRecolor"

Definitions:
- Conn = 4
- Holes(shape) = Count(Find("black regions", within=shape, where="fully enclosed by shape", conn=Conn))
- RegionAbove(row) = rows [0..row-1]
- RegionBelow(row) = rows [row+1..end]

Steps:
1) divider = Find("full-width horizontal stripe", where="all cells same nonzero color", extent="entire row")
2) top = RegionAbove(divider.row)
   bottom = RegionBelow(divider.row)

3) palette_swatches = Find("connected components", within=top, where="color != 0", conn=Conn)
   color_map = {}
   for swatch in palette_swatches:
       k = Holes(swatch)
       color_map[k] = ColorOf(swatch)

4) targets = Find("connected components", within=bottom, where="color != 0", conn=Conn)
   for shape in targets:
       k = Holes(shape)
       new_color = color_map[k]
       Paint(shape, new_color, preserve="black (0) holes")

5) Return canvas
[MESSAGE] [[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 2, 2, 2, 0, 3, 3, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 2, 2, 2, 0, 3, 0, 3, 0, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 2, 2, 2, 0, 3, 3, 3, 0, 1, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0],
 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0],
 [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 0],
 [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 3, 3, 3, 3, 0],
 [0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 3, 3, 3, 3, 0],
 [0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
 [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 2, 0, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

============================================================
Phase: train_1_predict
============================================================
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 2, 2, 2, 0, 3, 3, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 2, 2, 2, 0, 3, 0, 3, 0, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 2, 2, 2, 0, 3, 3, 3, 0, 1, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0],
 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0],
 [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 0],
 [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 3, 3, 3, 3, 0],
 [0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 3, 3, 3, 3, 0],
 [0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0],
 [0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 2, 0, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
[MESSAGE] Program "PaletteHolesRecolor_Universal"

Definitions:
- Conn = 4
- Holes(shape) = Count(Find("black regions", within=shape, where="fully enclosed by the shape", conn=Conn))
- Touches(component, edge) = Boolean(component intersects canvas edge)
- ColorOf(component) = DominantColor(component)
- NonDivider(c) = c != 0
- Outside(mask) = Complement(mask)

Helpers:
FindDivider():
  if Exists(Find("components", where="color == 1", conn=Conn)):
      return Largest(Find("components", where="color == 1", conn=Conn))
  else:
      return Largest(Find("components", where="touches at least two canvas edges", conn=Conn))

PaletteRegion(divider):
  H = CanvasHeight(); W = CanvasWidth()
  edges = { top: Touches(divider,"top"), bottom: Touches(divider,"bottom"),
            left: Touches(divider,"left"), right: Touches(divider,"right") }

  if edges.left AND edges.right:
      rows_of_div = Rows(divider)
      rmin = Min(rows_of_div); rmax = Max(rows_of_div)
      top_region = Region(rows=[0..rmin-1], cols=[0..W-1])
      bottom_region = Region(rows=[rmax+1..H-1], cols=[0..W-1])
      // choose side that contains palettes (nonzero components other than the divider)
      top_score = Count(Find("components", within=top_region, where="color != 0", conn=Conn))
      bottom_score = Count(Find("components", within=bottom_region, where="color != 0", conn=Conn))
      return (top_score >= bottom_score) ? top_region : bottom_region

  // L-corner cases: take interior rectangle bounded by divider extents along two adjacent edges
  if edges.top AND edges.left:
      r_lim = Max(Row(c) for c in Cells(divider) where Col(c)==0)
      c_lim = Max(Col(c) for c in Cells(divider) where Row(c)==0)
      return Region(rows=[0..r_lim-1], cols=[0..c_lim-1])

  if edges.top AND edges.right:
      r_lim = Max(Row(c) for c in Cells(divider) where Col(c)==W-1)
      c_lim = Min(Col(c) for c in Cells(divider) where Row(c)==0)
      return Region(rows=[0..r_lim-1], cols=[c_lim+1..W-1])

  if edges.bottom AND edges.left:
      r_lim = Min(Row(c) for c in Cells(divider) where Col(c)==0)
      c_lim = Max(Col(c) for c in Cells(divider) where Row(c)==H-1)
      return Region(rows=[r_lim+1..H-1], cols=[0..c_lim-1])

  if edges.bottom AND edges.right:
      r_lim = Min(Row(c) for c in Cells(divider) where Col(c)==W-1)
      c_lim = Min(Col(c) for c in Cells(divider) where Row(c)==H-1)
      return Region(rows=[r_lim+1..H-1], cols=[c_lim+1..W-1])

Steps:
1) divider = FindDivider()

2) palette_zone = PaletteRegion(divider)

3) palette_swatches = Find("connected components", within=palette_zone, where="color != 0", conn=Conn)
   // exclude the divider itself if it leaks into the zone
   palette_swatches = Filter(palette_swatches, where={ NOT Overlaps(component, divider) })

4) color_map = {}
   for swatch in palette_swatches {
       k = Holes(swatch)
       color_map[k] = ColorOf(swatch)
   }

5) targets = Find("connected components", where="color == 5", conn=Conn)
   targets = Filter(targets, where={ NOT Inside(component, palette_zone) })

6) for shape in targets {
       k = Holes(shape)
       if k in color_map {
           Paint(shape, color_map[k], preserve="black holes (0)")
       }
   }

7) Return canvas

============================================================
Phase: train_1_verify
============================================================
Program "PaletteHolesRecolor_Universal"

Definitions:
- Conn = 4
- Holes(shape) = Count(Find("black regions", within=shape, where="fully enclosed by the shape", conn=Conn))
- Touches(component, edge) = Boolean(component intersects canvas edge)
- ColorOf(component) = DominantColor(component)
- NonDivider(c) = c != 0
- Outside(mask) = Complement(mask)

Helpers:
FindDivider():
  if Exists(Find("components", where="color == 1", conn=Conn)):
      return Largest(Find("components", where="color == 1", conn=Conn))
  else:
      return Largest(Find("components", where="touches at least two canvas edges", conn=Conn))

PaletteRegion(divider):
  H = CanvasHeight(); W = CanvasWidth()
  edges = { top: Touches(divider,"top"), bottom: Touches(divider,"bottom"),
            left: Touches(divider,"left"), right: Touches(divider,"right") }

  if edges.left AND edges.right:
      rows_of_div = Rows(divider)
      rmin = Min(rows_of_div); rmax = Max(rows_of_div)
      top_region = Region(rows=[0..rmin-1], cols=[0..W-1])
      bottom_region = Region(rows=[rmax+1..H-1], cols=[0..W-1])
      // choose side that contains palettes (nonzero components other than the divider)
      top_score = Count(Find("components", within=top_region, where="color != 0", conn=Conn))
      bottom_score = Count(Find("components", within=bottom_region, where="color != 0", conn=Conn))
      return (top_score >= bottom_score) ? top_region : bottom_region

  // L-corner cases: take interior rectangle bounded by divider extents along two adjacent edges
  if edges.top AND edges.left:
      r_lim = Max(Row(c) for c in Cells(divider) where Col(c)==0)
      c_lim = Max(Col(c) for c in Cells(divider) where Row(c)==0)
      return Region(rows=[0..r_lim-1], cols=[0..c_lim-1])

  if edges.top AND edges.right:
      r_lim = Max(Row(c) for c in Cells(divider) where Col(c)==W-1)
      c_lim = Min(Col(c) for c in Cells(divider) where Row(c)==0)
      return Region(rows=[0..r_lim-1], cols=[c_lim+1..W-1])

  if edges.bottom AND edges.left:
      r_lim = Min(Row(c) for c in Cells(divider) where Col(c)==0)
      c_lim = Max(Col(c) for c in Cells(divider) where Row(c)==H-1)
      return Region(rows=[r_lim+1..H-1], cols=[0..c_lim-1])

  if edges.bottom AND edges.right:
      r_lim = Min(Row(c) for c in Cells(divider) where Col(c)==W-1)
      c_lim = Min(Col(c) for c in Cells(divider) where Row(c)==H-1)
      return Region(rows=[r_lim+1..H-1], cols=[c_lim+1..W-1])

Steps:
1) divider = FindDivider()

2) palette_zone = PaletteRegion(divider)

3) palette_swatches = Find("connected components", within=palette_zone, where="color != 0", conn=Conn)
   // exclude the divider itself if it leaks into the zone
   palette_swatches = Filter(palette_swatches, where={ NOT Overlaps(component, divider) })

4) color_map = {}
   for swatch in palette_swatches {
       k = Holes(swatch)
       color_map[k] = ColorOf(swatch)
   }

5) targets = Find("connected components", where="color == 5", conn=Conn)
   targets = Filter(targets, where={ NOT Inside(component, palette_zone) })

6) for shape in targets {
       k = Holes(shape)
       if k in color_map {
           Paint(shape, color_map[k], preserve="black holes (0)")
       }
   }

7) Return canvas
[MESSAGE] Program "PaletteHolesRecolor_Universal_v2"

Definitions:
- Conn = 4
- Holes(shape) = Count(Find("black regions", within=shape, where="fully enclosed by the shape", conn=Conn))
- ColorOf(component) = DominantColor(component)
- Touches(component, edge) = component intersects canvas edge
- BoxAround(component) = BoundingBox(component)
- Area(region) = NumberOfCells(region)

Helpers:
FindDivider():
  // Prefer a long, thin mono-colored bar touching opposite edges
  candidates = Find("connected components", where="color != 0", conn=Conn)
  bars = Filter(candidates, where={
      (Touches(component,"left") AND Touches(component,"right")) OR
      (Touches(component,"top") AND Touches(component,"bottom"))
  })
  if Count(bars) > 0:
      return Largest(bars)
  // Fallback: choose the largest 1-colored component (blue divider in given tasks)
  ones = Find("connected components", where="color == 1", conn=Conn)
  if Count(ones) > 0:
      return Largest(ones)
  return Largest(candidates)

SplitByDivider(divider):
  H = CanvasHeight(); W = CanvasWidth()
  bb = BoxAround(divider)
  // Horizontal divider
  if Height(bb) == 1 OR (Touches(divider,"left") AND Touches(divider,"right")):
      top = Region(rows=[0..bb.top-1], cols=[0..W-1])
      bottom = Region(rows=[bb.bottom+1..H-1], cols=[0..W-1])
      return (top, bottom, "horizontal")
  // Vertical divider
  left = Region(rows=[0..H-1], cols=[0..bb.left-1])
  right = Region(rows=[0..H-1], cols=[bb.right+1..W-1])
  return (left, right, "vertical")

ChoosePaletteZone(sideA, sideB):
  // Palette zone has small colored swatches distinct from background, fewer/larger holes grid
  scoreA = Count(Find("connected components", within=sideA, where="color != 0", conn=Conn))
  scoreB = Count(Find("connected components", within=sideB, where="color != 0", conn=Conn))
  // Prefer side with compact swatches near boundary and empty padding around
  densityA = TotalArea(Find("connected components", within=sideA, where="color != 0", conn=Conn)) / Area(sideA)
  densityB = TotalArea(Find("connected components", within=sideB, where="color != 0", conn=Conn)) / Area(sideB)
  // Palette side tends to have fewer total nonzero pixels and clear spacing
  return (densityA < densityB) ? sideA : sideB

BuildColorMap(palette_zone, divider):
  swatches = Find("connected components", within=palette_zone, where="color != 0", conn=Conn)
  swatches = Filter(swatches, where={ NOT Overlaps(component, divider) })
  // group by color to handle stacked 3x3 tiles forming one swatch
  color_map = {}
  for sw in swatches:
      k = Holes(sw)
      color_map[k] = ColorOf(sw)
  return color_map

Targets(nonpalette_zone):
  // Foreground blobs are the dominant nonzero color in non-palette zone
  comps = Find("connected components", within=nonpalette_zone, where="color != 0", conn=Conn)
  // pick the most frequent color in this zone
  colors = Histogram(Map(comps, ColorOf))
  fg_color = ArgMax(colors)
  return Filter(comps, where={ ColorOf(component) == fg_color })

Steps:
1) divider = FindDivider()
2) (sideA, sideB, orient) = SplitByDivider(divider)
3) palette_zone = ChoosePaletteZone(sideA, sideB)
4) nonpalette_zone = (palette_zone == sideA) ? sideB : sideA
5) color_map = BuildColorMap(palette_zone, divider)
6) blobs = Targets(nonpalette_zone)
7) for b in blobs:
       k = Holes(b)
       if k in color_map:
           Paint(b, color_map[k], preserve="black holes (0)")
8) Return canvas

============================================================
Phase: test_predict
============================================================
Program "PaletteHolesRecolor_Universal_v2"

Definitions:
- Conn = 4
- Holes(shape) = Count(Find("black regions", within=shape, where="fully enclosed by the shape", conn=Conn))
- ColorOf(component) = DominantColor(component)
- Touches(component, edge) = component intersects canvas edge
- BoxAround(component) = BoundingBox(component)
- Area(region) = NumberOfCells(region)

Helpers:
FindDivider():
  // Prefer a long, thin mono-colored bar touching opposite edges
  candidates = Find("connected components", where="color != 0", conn=Conn)
  bars = Filter(candidates, where={
      (Touches(component,"left") AND Touches(component,"right")) OR
      (Touches(component,"top") AND Touches(component,"bottom"))
  })
  if Count(bars) > 0:
      return Largest(bars)
  // Fallback: choose the largest 1-colored component (blue divider in given tasks)
  ones = Find("connected components", where="color == 1", conn=Conn)
  if Count(ones) > 0:
      return Largest(ones)
  return Largest(candidates)

SplitByDivider(divider):
  H = CanvasHeight(); W = CanvasWidth()
  bb = BoxAround(divider)
  // Horizontal divider
  if Height(bb) == 1 OR (Touches(divider,"left") AND Touches(divider,"right")):
      top = Region(rows=[0..bb.top-1], cols=[0..W-1])
      bottom = Region(rows=[bb.bottom+1..H-1], cols=[0..W-1])
      return (top, bottom, "horizontal")
  // Vertical divider
  left = Region(rows=[0..H-1], cols=[0..bb.left-1])
  right = Region(rows=[0..H-1], cols=[bb.right+1..W-1])
  return (left, right, "vertical")

ChoosePaletteZone(sideA, sideB):
  // Palette zone has small colored swatches distinct from background, fewer/larger holes grid
  scoreA = Count(Find("connected components", within=sideA, where="color != 0", conn=Conn))
  scoreB = Count(Find("connected components", within=sideB, where="color != 0", conn=Conn))
  // Prefer side with compact swatches near boundary and empty padding around
  densityA = TotalArea(Find("connected components", within=sideA, where="color != 0", conn=Conn)) / Area(sideA)
  densityB = TotalArea(Find("connected components", within=sideB, where="color != 0", conn=Conn)) / Area(sideB)
  // Palette side tends to have fewer total nonzero pixels and clear spacing
  return (densityA < densityB) ? sideA : sideB

BuildColorMap(palette_zone, divider):
  swatches = Find("connected components", within=palette_zone, where="color != 0", conn=Conn)
  swatches = Filter(swatches, where={ NOT Overlaps(component, divider) })
  // group by color to handle stacked 3x3 tiles forming one swatch
  color_map = {}
  for sw in swatches:
      k = Holes(sw)
      color_map[k] = ColorOf(sw)
  return color_map

Targets(nonpalette_zone):
  // Foreground blobs are the dominant nonzero color in non-palette zone
  comps = Find("connected components", within=nonpalette_zone, where="color != 0", conn=Conn)
  // pick the most frequent color in this zone
  colors = Histogram(Map(comps, ColorOf))
  fg_color = ArgMax(colors)
  return Filter(comps, where={ ColorOf(component) == fg_color })

Steps:
1) divider = FindDivider()
2) (sideA, sideB, orient) = SplitByDivider(divider)
3) palette_zone = ChoosePaletteZone(sideA, sideB)
4) nonpalette_zone = (palette_zone == sideA) ? sideB : sideA
5) color_map = BuildColorMap(palette_zone, divider)
6) blobs = Targets(nonpalette_zone)
7) for b in blobs:
       k = Holes(b)
       if k in color_map:
           Paint(b, color_map[k], preserve="black holes (0)")
8) Return canvas
